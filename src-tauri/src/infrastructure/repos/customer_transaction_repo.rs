use crate::common::error::AppError;
use crate::common::mutex_ext::MutexExt;
use crate::domain::models::customer_tx_detail::CustomerTxDetail;
use crate::domain::models::CustomerTransaction;
use crate::domain::report_models::sales_details::SalesReportDetailRow;
use crate::domain::report_models::sales_details::SalesReportDetails;
use crate::domain::repos::CustomerTransactionRepoTrait;
use chrono::{Duration, NaiveDateTime};
use rusqlite::{params, Connection};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

pub struct SqliteCustomerTransactionRepo {
    conn: Arc<Mutex<Connection>>,
}

impl SqliteCustomerTransactionRepo {
    pub const fn new(conn: Arc<Mutex<Connection>>) -> Self {
        Self { conn }
    }
}

impl CustomerTransactionRepoTrait for SqliteCustomerTransactionRepo {
    fn create(&self, tx: &CustomerTransaction) -> Result<(), AppError> {
        let conn = self.conn.safe_lock()?;
        if tx.order_id > 0 {
            conn.execute(
                "INSERT INTO customer_transactions
                 (order_id, customer_mdoc, operator_mdoc, date, note)
                 VALUES (?1,?2,?3,?4,?5)",
                params![
                    tx.order_id,
                    tx.customer_mdoc,
                    tx.operator_mdoc,
                    tx.date,
                    tx.note,
                ],
            )?;
        } else {
            conn.execute(
                "INSERT INTO customer_transactions
                 (customer_mdoc, operator_mdoc, date, note)
                 VALUES (?1,?2,?3,?4)",
                params![tx.customer_mdoc, tx.operator_mdoc, tx.date, tx.note,],
            )?;
        }
        Ok(())
    }

    // for use with atomic_tx
    fn create_with_tx(
        &self,
        tx_data: &CustomerTransaction,
        tx: &rusqlite::Transaction<'_>,
    ) -> Result<i32, AppError> {
        if tx_data.order_id > 0 {
            // Caller provided a specific order_id; preserve it
            tx.execute(
                "INSERT INTO customer_transactions
             (order_id, customer_mdoc, operator_mdoc, date, note)
             VALUES (?1, ?2, ?3, ?4, ?5)",
                rusqlite::params![
                    tx_data.order_id,
                    tx_data.customer_mdoc,
                    tx_data.operator_mdoc,
                    tx_data.date,
                    tx_data.note,
                ],
            )?;
            Ok(tx_data.order_id)
        } else {
            // No order_id supplied; let SQLite autogenerate
            tx.execute(
                "INSERT INTO customer_transactions
             (customer_mdoc, operator_mdoc, date, note)
             VALUES (?1, ?2, ?3, ?4)",
                rusqlite::params![
                    tx_data.customer_mdoc,
                    tx_data.operator_mdoc,
                    tx_data.date,
                    tx_data.note,
                ],
            )?;
            // Retrieve the autogenerated ID
            let new_id = tx.last_insert_rowid() as i32;
            Ok(new_id)
        }
    }

    fn get(&self, order_id: i32) -> Result<Option<CustomerTransaction>, AppError> {
        let conn = self.conn.safe_lock()?;
        let mut stmt = conn.prepare(
            "SELECT order_id, customer_mdoc, operator_mdoc, date, note
             FROM customer_transactions WHERE order_id = ?1",
        )?;
        let mut rows = stmt.query(params![order_id])?;
        if let Some(r) = rows.next()? {
            Ok(Some(CustomerTransaction {
                order_id: r.get(0)?,
                customer_mdoc: r.get(1)?,
                operator_mdoc: r.get(2)?,
                date: r.get(3)?,
                note: r.get(4)?,
            }))
        } else {
            Ok(None)
        }
    }

    fn list(&self) -> Result<Vec<CustomerTransaction>, AppError> {
        let conn = self.conn.safe_lock()?;
        let mut stmt = conn.prepare(
            "SELECT order_id, customer_mdoc, operator_mdoc, date, note
             FROM customer_transactions",
        )?;
        let txs = stmt
            .query_map([], |r| {
                Ok(CustomerTransaction {
                    order_id: r.get(0)?,
                    customer_mdoc: r.get(1)?,
                    operator_mdoc: r.get(2)?,
                    date: r.get(3)?,
                    note: r.get(4)?,
                })
            })?
            .collect::<Result<Vec<_>, _>>()?;
        Ok(txs)
    }

    fn search(
        &self,
        limit: i32,
        offset: i32,
        mdoc: Option<i32>,
        date: Option<String>,
        search: Option<String>,
    ) -> Result<Vec<(CustomerTransaction, String, i32)>, AppError> {
        let conn = self
            .conn
            .lock()
            .map_err(|e| AppError::LockPoisoned(e.to_string()))?;
        let mut sql = "\
            SELECT t.order_id,
                   t.customer_mdoc,
                   t.operator_mdoc,
                   t.date,
                   t.note,
                   o.name       AS operator_name,
                   COALESCE(d.spent,0) AS spent
            FROM customer_transactions t
            JOIN operators o ON t.operator_mdoc = o.mdoc
            LEFT JOIN (
              SELECT order_id,
                     SUM(quantity * price) AS spent
              FROM customer_tx_detail
              GROUP BY order_id
            ) d ON t.order_id = d.order_id
            WHERE t.customer_mdoc = ?1
        "
        .to_string();
        let mut params: Vec<&dyn rusqlite::ToSql> = Vec::new();
        params.push(&mdoc);
        let mut string_params: Vec<String> = Vec::new();

        // date filter
        if let Some(ref d) = date {
            sql.push_str(" AND date(date)=date(?)");
            params.push(d);
        }
        // search on multiple fields
        if let Some(ref s) = search {
            sql.push_str(" AND (t.customer_mdoc LIKE ? OR t.operator_mdoc LIKE ? OR t.order_id LIKE ? OR t.note LIKE ?)");
            let pat = format!("%{s}%");
            string_params.push(pat);
            let p = string_params.last().ok_or_else(|| {
                AppError::Unexpected("customer_transactions pattern missing".into())
            })?;
            // push four times for each placeholder
            params.push(p);
            params.push(p);
            params.push(p);
            params.push(p);
        }

        // ordering + pagination
        sql.push_str(" ORDER BY t.date DESC LIMIT ? OFFSET ?");
        params.push(&limit);
        params.push(&offset);

        let mut stmt = conn.prepare(&sql)?;
        let rows = stmt.query_map(params.as_slice(), |r| {
            let ct = CustomerTransaction {
                order_id: r.get(0)?,
                customer_mdoc: r.get(1)?,
                operator_mdoc: r.get(2)?,
                date: r.get(3)?,
                note: r.get(4)?,
            };
            let operator_name: String = r.get(5)?;
            let spent: i64 = r.get(6)?;
            Ok((ct, operator_name, spent as i32))
        })?;
        rows.collect::<Result<_, _>>().map_err(Into::into)
    }

    fn count(
        &self,
        mdoc: Option<i32>,
        date: Option<String>,
        search: Option<String>,
    ) -> Result<i32, AppError> {
        let conn = self
            .conn
            .lock()
            .map_err(|e| AppError::LockPoisoned(e.to_string()))?;
        let mut sql =
            "SELECT COUNT(*) FROM customer_transactions WHERE customer_mdoc = ?1".to_string();
        let mut params: Vec<&dyn rusqlite::ToSql> = Vec::new();
        params.push(&mdoc);
        let mut string_params: Vec<String> = Vec::new();

        if let Some(ref d) = date {
            sql.push_str(" AND date(date)=date(?)");
            params.push(d);
        }
        if let Some(ref s) = search {
            sql.push_str(" AND (customer_mdoc LIKE ? OR operator_mdoc LIKE ? OR order_id LIKE ? OR note LIKE ?)");
            let pat = format!("%{s}%");
            string_params.push(pat);
            let p = string_params.last().ok_or_else(|| {
                AppError::Unexpected("customer_transactions count pattern missing".into())
            })?;
            params.push(p);
            params.push(p);
            params.push(p);
            params.push(p);
        }

        let mut stmt = conn.prepare(&sql)?;
        stmt.query_row(params.as_slice(), |r| {
            let cnt: i64 = r.get(0)?;
            Ok(cnt as i32)
        })
        .map_err(Into::into)
    }

    fn get_with_details_and_balance(
        &self,
        order_id: i32,
    ) -> Result<(CustomerTransaction, Vec<(CustomerTxDetail, String)>, i32), AppError> {
        let conn = self.conn.safe_lock()?;

        // fetch the transaction
        let tx: CustomerTransaction = conn.query_row(
            "SELECT order_id, customer_mdoc, operator_mdoc, date, note FROM customer_transactions WHERE order_id = ?1",
            rusqlite::params![order_id],
            |row| Ok(CustomerTransaction {
                order_id: row.get(0)?,
                customer_mdoc: row.get(1)?,
                operator_mdoc: row.get(2)?,
                date: row.get(3)?,
                note: row.get(4)?,
            }),
        )?;

        // fetch the line items + product description
        let mut stmt = conn.prepare(
            "SELECT d.detail_id, d.order_id, d.upc, d.quantity, d.price, p.desc
             FROM customer_tx_detail d
             JOIN products p ON p.upc = d.upc
             WHERE d.order_id = ?1",
        )?;
        let details = stmt
            .query_map(rusqlite::params![order_id], |row| {
                Ok((
                    CustomerTxDetail {
                        detail_id: row.get(0)?,
                        order_id: row.get(1)?,
                        upc: row.get(2)?,
                        quantity: row.get(3)?,
                        price: row.get(4)?,
                        // no created_at here
                    },
                    row.get(5)?,
                ))
            })?
            .collect::<Result<_, _>>()?;

        // compute balance
        let balance: i32 = conn.query_row(
            "
            SELECT COALESCE(ct.added,0) - COALESCE(sp.spent,0)
            FROM customer c
            LEFT JOIN (
              SELECT mdoc, SUM(CASE WHEN tx_type='Deposit' THEN amount WHEN tx_type='Withdrawal' THEN -amount ELSE 0 END) AS added
              FROM club_transactions GROUP BY mdoc
            ) ct ON c.mdoc = ct.mdoc
            LEFT JOIN (
              SELECT t.customer_mdoc AS mdoc, SUM(d.quantity*d.price) AS spent
              FROM customer_transactions t
              JOIN customer_tx_detail d ON d.order_id = t.order_id
              GROUP BY t.customer_mdoc
            ) sp ON c.mdoc = sp.mdoc
            WHERE c.mdoc = ?1
            ",
            rusqlite::params![tx.customer_mdoc],
            |row| row.get(0),
        )?;

        Ok((tx, details, balance))
    }

    // Get total for mdoc between `week_start` (inclusive) and `week_start + 7 days` (exclusive).
    fn get_weekly_spent(
        &self,
        customer_mdoc: i32,
        week_start: NaiveDateTime,
    ) -> Result<i32, AppError> {
        let conn = self.conn.safe_lock()?;
        let week_end = week_start + Duration::days(7);
        let mut stmt = conn.prepare(
            "SELECT COALESCE(SUM(d.quantity * d.price), 0)
             FROM customer_transactions t
             JOIN customer_tx_detail d ON t.order_id = d.order_id
             WHERE t.customer_mdoc = ?1
               AND t.date >= ?2
               AND t.date < datetime(?3, '+1 day')",
        )?;

        let spent: i32 =
            stmt.query_row(params![customer_mdoc, week_start, week_end], |r| r.get(0))?;

        Ok(spent)
    }

    fn get_sales_details_data(
        &self,
        start: NaiveDateTime,
        end: NaiveDateTime,
    ) -> Result<Vec<SalesReportDetails>, AppError> {
        let conn = self.conn.safe_lock()?;

        // fetch the "header" rows with aggregates
        let mut hdr_stmt = conn.prepare(
            "SELECT
                t.order_id,
                t.customer_mdoc,
                t.operator_mdoc,
                t.date,
                t.note,
                c.name,
                SUM(d.quantity)    AS item_count,
                SUM(d.quantity*d.price) AS order_total
             FROM customer_transactions t
             JOIN customer_tx_detail d ON d.order_id = t.order_id
             JOIN customer c ON t.customer_mdoc = c.mdoc
             WHERE t.date >= ?1 AND t.date < datetime(?2, '+1 day')
             GROUP BY t.order_id
             ORDER BY t.date, t.order_id",
        )?;

        let mut headers = Vec::new();
        let rows = hdr_stmt.query_map(params![start, end], |r| {
            Ok((
                CustomerTransaction {
                    order_id: r.get(0)?,
                    customer_mdoc: r.get(1)?,
                    operator_mdoc: r.get(2)?,
                    date: r.get(3)?,
                    note: r.get(4)?,
                },
                r.get::<_, String>(5)?,     // customer_name
                r.get::<_, i64>(6)? as i32, // item_count
                r.get::<_, i64>(7)? as i32, // order_total
            ))
        })?;

        for hdr in rows {
            let (tx, customer_name, item_count, order_total) = hdr?;
            headers.push((tx, customer_name, item_count, order_total));
        }

        if headers.is_empty() {
            return Ok(Vec::new());
        }

        // fetch details for all these orders in one go
        let ids: Vec<i32> = headers.iter().map(|(tx, _, _, _)| tx.order_id).collect();
        let placeholders = std::iter::repeat_n("?", ids.len())
            .collect::<Vec<_>>()
            .join(", ");
        let query = format!(
            "SELECT d.detail_id, d.order_id, d.upc, d.quantity, d.price, p.desc
             FROM customer_tx_detail d
             JOIN products p ON d.upc = p.upc
             WHERE d.order_id IN ({placeholders})
             ORDER BY d.order_id, d.detail_id"
        );

        let mut det_stmt = conn.prepare(&query)?;
        let det_rows = det_stmt.query_map(rusqlite::params_from_iter(ids.iter()), |r| {
            Ok(SalesReportDetailRow {
                detail_id: r.get(0)?,
                order_id: r.get(1)?,
                upc: r.get(2)?,
                quantity: r.get(3)?,
                price: r.get(4)?,
                product_name: r.get(5)?,
            })
        })?;

        // group details by order_id
        let mut details_map: HashMap<i32, Vec<SalesReportDetailRow>> = HashMap::new();
        for det in det_rows {
            let det = det?;
            details_map.entry(det.order_id).or_default().push(det);
        }

        // assemble
        let mut out = Vec::with_capacity(headers.len());
        for (tx, customer_name, item_count, order_total) in headers {
            let details = details_map.remove(&tx.order_id).unwrap_or_default();
            out.push(SalesReportDetails {
                tx,
                customer_name,
                item_count,
                order_total,
                details,
            });
        }

        Ok(out)
    }
}

#[cfg(test)]
mod repo_tests {
    use super::*;
    use crate::infrastructure::db::create_connection;
    use chrono::Utc;
    use std::sync::Arc;

    impl SqliteCustomerTransactionRepo {
        pub fn create_table_if_not_exists(&self) -> Result<(), AppError> {
            let conn = self.conn.safe_lock()?;
            conn.execute_batch(
                "
            CREATE TABLE IF NOT EXISTS customer_transactions (
                order_id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_mdoc INTEGER NOT NULL,
                operator_mdoc INTEGER NOT NULL,
                date TEXT,
                note TEXT
            );
            ",
            )?;
            Ok(())
        }
    }

    #[test]
    fn repo_crud_flow() {
        let conn = Arc::new(create_connection(":memory:").unwrap());
        let repo = SqliteCustomerTransactionRepo::new(Arc::clone(&conn));

        repo.create_table_if_not_exists().unwrap();

        assert!(repo.get(1).unwrap().is_none());
        assert!(repo.list().unwrap().is_empty());

        // insert with auto-id
        let tx = CustomerTransaction {
            order_id: 0,
            customer_mdoc: 3,
            operator_mdoc: 4,
            date: Some(Utc::now().naive_utc()),
            note: Some("hi".into()),
        };
        repo.create(&tx).unwrap();
        let all = repo.list().unwrap();
        assert_eq!(all.len(), 1);
        let id = all[0].order_id;
        assert!(id > 0);

        // can get by that id
        let got = repo.get(id).unwrap().unwrap();
        assert_eq!(got.customer_mdoc, 3);

        // explicit-id insert
        let tx2 = CustomerTransaction {
            order_id: 7,
            ..tx.clone()
        };
        repo.create(&tx2).unwrap();
        assert!(repo.get(7).unwrap().is_some());
    }
}
